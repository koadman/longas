package Phylosift::Command::demux;
use Phylosift -command;
use Phylosift::Settings;
use Phylosift::Phylosift;
use JSON;
use Carp;
use Phylosift::Utilities qw(debug ps_open miss);
use IO::Zlib;

use strict;
use warnings;

our $VERSION = "v1.0.1";

sub description {
	return
	  "phylosift demux - process a barcoded Illumina run into a single interleaved file. Input is a directory of FastQ files generated by Illumina's pipeline."
	  ;
}

sub abstract {
	return "process a barcoded Illumina run into a single interleaved file. Input is a directory of FastQ files generated by Illumina's pipeline.";
}

sub usage_desc { "demux %o <illumina directory>" }

sub options {
	return (
			 [ "sample-map=s",    "A file with the list of samples names, their barcode sequences, and any sample metadata", { required => 1 } ],
			 [ "barcode-table=s", "A table containing barcode and adapter information",                                      { required => 1 } ],
			 [ "output=s",        "Name of the output file",                                                                 { required => 1 } ],
			 [ "barcode-pos=i",  "Position in read(s) where barcode exists (zero-based)", { required => 1, default => 0 } ],
			 [ "stats-output=s", "Name of an output file for sample summary statistics" ],
			 [ "flash",          "Assemble overlapping read pairs into a single longer read with FLASH" ],
			 [ "samplefiles",    "Output each sample separately" ],
			 [ "no-interleaving", "Save reads 1 and 2 in separate files instead of interleaving them" ],
			 [ "rev-barcode=i",  "The specified barcode is read in the reverse complement direction" ],
	);
}

sub validate {
	my ( $self, $opt, $args ) = @_;
}

sub load_opt {
	my %args = @_;
	my $opt  = $args{opt};
	$Phylosift::Settings::configuration        = $opt->{config};
	$Phylosift::Settings::disable_update_check = $opt->{disable_updates};
	$Phylosift::Settings::my_debug             = $opt->{debug};

	$Phylosift::Utilities::debuglevel = $Phylosift::Settings::my_debug || 0;
}

sub execute {
	my ( $self, $opt, $args ) = @_;
	load_opt( opt => $opt );
	Phylosift::Command::sanity_check();
	Phylosift::Utilities::program_checks();
	my $ps;
	Phylosift::Utilities::data_checks( self => $ps );

	croak("Please provide the path to a directory of Illumina fastq files") unless defined @$args[0];

	my %sample_map = read_sample_file( sample_file => $opt->{sample_map}, rev_barcode => $opt->{rev_barcode} );
	my %barcode_table = read_barcodes( barcode_file => $opt->{barcode_table}, rev_barcode => $opt->{rev_barcode} );
	my $barcode_length;
	foreach my $read(keys(%barcode_table)){
		foreach my $bc(keys(%{$barcode_table{$read}})){
			$barcode_length = length($bc) unless defined($barcode_length);
			die "Error barcodes have unequal lengths" if $barcode_length != length($bc);
		}
	}
	print "Barcode length is $barcode_length\n";
	my $illumina_dir  = @$args[0];
	my @files         = <$illumina_dir/*_R1_001.fastq.gz>;
	croak(
		"Unable to locate any Illumina FastQ files in $illumina_dir\nPlease check that the directory contains FastQ files named according to Illumina's convention, e.g. names ending with R1_001.fastq.gz, R2_001.fastq.gz, etc"
	) unless @files > 0;

	my %outstream;
	my %outstreams;
	if ( $opt->{flash} ) {
		my $gzout_name = $opt->{output};
		$outstream{both} = ps_open("| flash -I -z -o $gzout_name --max-overlap=250 --min-overlap=15 -");
	} elsif( $opt->{samplefiles} ) {
		foreach my $barcode(keys(%sample_map)){
			my $sample = $sample_map{$barcode};
			unless( $opt->{no_interleaving} ){
				$outstream{$barcode}{both} = new IO::Zlib;
				$outstream{$barcode}{both}->open( "$sample.fastq.gz", "wb9" );
			}else{
				$outstream{$barcode}{r1} = new IO::Zlib;
				$outstream{$barcode}{r2} = new IO::Zlib;
				$outstream{$barcode}{r1}->open( "$sample.r1.fastq.gz", "wb9" );
				$outstream{$barcode}{r2}->open( "$sample.r2.fastq.gz", "wb9" );
			}
		}
	} else {
		my $gzout_name = $opt->{output};
		unless( $opt->{no_interleaving} ){
			$outstream{both} = new IO::Zlib;
			$gzout_name .= ".fastq.gz" unless $gzout_name =~ /\.gz$/;
			$outstream{both}->open( $gzout_name, "wb9" );
		}else{
			$outstream{r1} = new IO::Zlib;
			$outstream{r2} = new IO::Zlib;
			$outstream{r1}->open( "$gzout_name.r1.fastq.gz", "wb9" );
			$outstream{r2}->open( "$gzout_name.r2.fastq.gz", "wb9" );
		}
	}

	foreach my $file (@files) {
		print STDERR "Processing $file\n";
		$file =~ m/^(\S+)_\S\S_(\d+).fastq.gz/;
		process_barcodes(
						  barcode     => \%barcode_table,
						  sample_map  => \%sample_map,
						  gzout       => \%outstream,
						  in_file     => $file,
						  barcode_pos => $opt->{barcode_pos},
						  barcode_len => $barcode_length,
						  outstreams  => \%outstreams,
						  output_base => $opt->{output}
		);
	}
}

sub process_barcodes {
	my %args        = @_;
	my $barcode     = $args{barcode} || miss("barcode");
	my $sample_map  = $args{sample_map} || miss("sample_map");
	my $gzout       = $args{gzout} || miss("gzout");
	my $in_file     = $args{in_file} || miss("in_file");
	my $barcode_pos = $args{barcode_pos};
	my $barcode_len = $args{barcode_len} || miss("barcode_len");
	my $outstreams  = $args{outstreams};
	my $output_base = $args{output_base};

	$in_file =~ m/^(\S+)_\S\S_(\d+).fastq.gz/;
	my $core  = $1;
	my $index = $2;

	# logic: try four-read with names R1,I1,I2,R2, then R1,R2,R3,R4, then R1,R2,R3, finally R1,R2 w/inline barcodes
	my $i1_file = "$core"."_I1_$index.fastq.gz";
	$i1_file = "$core"."_R2_$index.fastq.gz" unless -e $i1_file;
	$i1_file = undef unless -e $i1_file;
	my $i2_file = "$core"."_I2_$index.fastq.gz";
	$i2_file = "$core"."_R3_$index.fastq.gz" unless -e $i2_file;
	$i2_file = undef unless -e $i2_file;
	my $r2_file = "$core"."_R4_$index.fastq.gz";
	$r2_file = "$core"."_R3_$index.fastq.gz" unless -e $r2_file;
	$r2_file = "$core"."_R2_$index.fastq.gz" unless -e $r2_file;
	$i1_file = undef if $i1_file eq $r2_file;
	$i1_file = undef if $i1_file eq $r2_file;
	print STDERR "i1_file $i1_file\ni2_file $i2_file\nr2_file $r2_file\n\n";

	my %STREAMS;
	$STREAMS{1} = ps_open("gzip -cd $in_file |");
	$STREAMS{2} = ps_open("gzip -cd $i1_file |") if defined $i1_file;
	$STREAMS{3} = ps_open("gzip -cd $i2_file |") if defined $i2_file;
	$STREAMS{4} = ps_open("gzip -cd $r2_file |");

	my $process_limit = 99999999999999;
	my %bc_counts;
	my %sample_counts;
	my $counter  = 0;
	my $defcount = 0;
	my $scount   = 0;
	while (1) {
		$counter++;
		last if $counter > $process_limit;
		my %bcdata =
		  get_barcoded_read(
							 STREAMS       => \%STREAMS,
							 barcode       => $barcode,
							 barcode_pos   => $barcode_pos,
							 barcode_len   => $barcode_len,
							 sample_map    => $sample_map,
							 sample_counts => \%sample_counts
		  );
		last if !defined($bcdata{reads});
		my $readname = $bcdata{reads}->{1}[0];
		$readname =~ s/^@/>/g;
		$readname =~ s/ .+//g;

		if ($bcdata{defined}) {
			my $jbc  = join( ":", @{$bcdata{bc}} );
			$bc_counts{$jbc} = 0 unless defined( $bc_counts{$jbc} );
			$bc_counts{$jbc}++;
			$defcount++;

			my $r1_out = defined($gzout->{both}) ? $gzout->{both} : $gzout->{r1};
			my $r2_out = defined($gzout->{both}) ? $gzout->{both} : $gzout->{r2};
			$r1_out = defined($r1_out) ? $r1_out : $gzout->{$jbc}{both};
			$r2_out = defined($r2_out) ? $r2_out : $gzout->{$jbc}{both};
			print $r1_out @{ $bcdata{reads}->{1} } if defined $r1_out;
			print $r2_out @{ $bcdata{reads}->{4} } if defined $r1_out;
		}
		$scount += $bcdata{sample};
		print "$scount / $defcount / $counter reads: matching samples / matching barcodes / total\n" if ( $counter % 1000 == 0 );
	}
	foreach my $STRM(values(%STREAMS)){
		close $STRM;
	}

}

sub get_barcoded_read {
	my %args          = @_;
	my $STREAMS       = $args{STREAMS} || miss("STREAMS");
	my $barcode       = $args{barcode} || miss("barcode");
	my $barcode_pos   = $args{barcode_pos};
	my $barcode_len   = $args{barcode_len} || miss("barcode_len");
	my $sample_map    = $args{sample_map} || miss("sample_map");
	my $sample_counts = $args{sample_counts} || miss("sample_counts");

	my %reads;
	for ( my $i = 1; $i < 5; $i++ ) {
		$reads{$i} = ();
		for ( my $j = 0; $j < 4; $j++ ) {
			my $si = $STREAMS->{$i};
			$reads{$i}[$j] = <$si> if defined $si;
			return if ( $i == 1 && !defined( $reads{$i}[$j] ) );
		}
	}
	my @bc = ("","");
	my @rbc = ("","","","","");
	my $defined_bc = 1;    # 1 if all barcodes were defined in the table
	my $sample_bc  = 0;    # 1 if the combination of barcodes matches a sample
	my $linker     = 1;    # 1 if the linker sequence was found in both reads
	my $r1d        = 0;
	my $r2d        = 0;
	foreach my $rid ( sort {$a <=> $b} keys(%$barcode) ) {
		my $b = substr( $reads{$rid}[1], $barcode_pos, $barcode_len );
		
#		my @qual = split( //, substr( $reads{$rid}[3], $barcode_pos, $barcode_len ) );
#		my $qavg = 0;
#		foreach my $qq(@qual){ $qavg += ord($qq); }
#		$qavg /= @qual;
#		print STDERR "qavg too low: $qavg\n" if $qavg <= 60;
#		next unless $qavg > 60;

		# try to error-correct the barcode
		my $ecb = $b;
		$ecb = $barcode->{$rid}{$b}{parent} if defined $barcode->{$rid}{$b};
#		print "barcode $b parent .".$barcode->{$rid}{$b}{parent}."\n"; # if $rid == 4;
		$defined_bc = 0 unless defined $barcode->{$rid}{$ecb};
		$r1d = $rid if defined $barcode->{$rid}{$ecb} && $rid == 1 || $rid == 3;
		$r2d = $rid if defined $barcode->{$rid}{$ecb} && $rid == 4 || $rid == 2;
		$bc[0] = $ecb if $r1d == $rid;
		$bc[1] = $ecb if $r2d == $rid;
#		print "read $rid $ecb undefined\n" unless $defined_bc; # || $rid != 4;

		# look for linker sequence, if known
		my $any_matched = 0;
		if( defined( $barcode->{$rid}{$ecb} ) && defined( $barcode->{$rid}{$ecb}{linker} ) ) {
			eval {
			require String::Approx;
			my $linker_start = $barcode->{$rid}{$ecb}{trim_len} - length($barcode->{$rid}{$ecb}{linker}) - 5;
			$any_matched = String::Approx::amatch($barcode->{$rid}{$ecb}{linker}, [ "I2","D2","S25%" ], substr( $reads{$rid}[1], $linker_start, length($barcode->{$rid}{$ecb}{linker}) + 10 ));
#			print STDERR "Found linker ".$barcode->{$rid}{$ecb}{linker}." in ".substr( $reads{$rid}[1], $linker_start, length($barcode->{$rid}{$ecb}{linker}) + 10 )."\n" if $any_matched;
			$linker = $any_matched && $linker;
			$defined_bc = 0 unless $any_matched;
			$r1d = 0 if !$any_matched && $rid == 1;
			$r2d = 0 if !$any_matched && $rid == 4;
			}
		}

		# trim the read if the linker was found
		if ( $any_matched && defined( $barcode->{$rid}{$ecb} ) && defined( $barcode->{$rid}{$ecb}{trim_len} ) ) {
			$reads{$rid}[1] = substr( $reads{$rid}[1], $barcode->{$rid}{$ecb}{trim_len} );
			$reads{$rid}[3] = substr( $reads{$rid}[3], $barcode->{$rid}{$ecb}{trim_len} );
		}
	}

	# have the barcodes. tag the sequence with the barcodes and sample names
	my $joined_bc  = join( ":", @bc );
#	print "Joined bc $joined_bc\n";
	chomp $reads{1}[0];
	$reads{1}[0] .= " barcode=$joined_bc";
	chomp $reads{4}[0];
	$reads{4}[0] .= " barcode=$joined_bc";
	if ( $defined_bc && defined( $sample_map->{$joined_bc} && $linker) ) {
		$sample_counts->{ $sample_map->{$joined_bc} } = 0 unless defined $sample_counts->{ $sample_map->{$joined_bc} };
		$sample_counts->{ $sample_map->{$joined_bc} }++;
		my $readid = $sample_map->{$joined_bc}."_".$sample_counts->{ $sample_map->{$joined_bc} }." ";
		$reads{1}[0] =~ s/^\@/\@$readid/;
		$reads{4}[0] =~ s/^\@/\@$readid/;
		$sample_bc = 1;
	}
	$reads{1}[0] .= "\n";
	$reads{4}[0] .= "\n";

	return ( reads => \%reads, bc => \@bc, rbc => \@rbc, defined => $defined_bc, sample => $sample_bc, r1d => $r1d, r2d => $r2d );
}

# file format
# barcode	bc_name	read_id trim_len random_pos random_len
#
# barcode: nucleotide sequence of the barcode
# bc_name: a name for the barcode
# read_id: the read containing the barcode -- For Illumina this will usually be 1, 2, 3, or 4
# trim_len: if not empty, then the amount to trim from the read containing the barcode
# random_pos: if not empty, position in the barcode read of a randomly synthesized read identifier
# random_len: if not empty, length in the read of a randomly synthesized read identifier
sub read_barcodes {
	my %args = @_;
	my $barcode_file = $args{barcode_file} || miss("barcode_file");
	my %barcode;
	my $INBC = ps_open( $args{barcode_file} );
	while ( my $line = <$INBC> ) {
		chomp($line);
		next if $line =~ /^#/;    # skip a header line
		my @line = split( /\t/, $line );
		next if @line < 2; # probably an empty line, skip it.
		my $rid = $line[2];
		if(defined($args{rev_barcode}) && $rid == $args{rev_barcode}){
			# reverse complement the DNA sequence
			$line[0] = reverse($line[0]);
		        $line[0] =~ tr/ABCDGHMNRSTUVWXYabcdghmnrstuvwxy/TVGHCDKNYSAABWXRtvghcdknysaabwxr/;			
		}
		warn("Read ID of $rid may be out of range for barcode $line[0]") unless $rid > 0 && $rid <= 4;
		$barcode{$rid}{ $line[0] }{name}       = $line[1];
		$barcode{$rid}{ $line[0] }{parent}     = $line[0];
		$barcode{$rid}{ $line[0] }{trim_len}   = $line[3] if defined $line[3];
		$barcode{$rid}{ $line[0] }{random_pos} = $line[4] if defined $line[4];
		$barcode{$rid}{ $line[0] }{random_len} = $line[5] if defined $line[5];
		$barcode{$rid}{ $line[0] }{linker}     = $line[6] if defined $line[6];

		# insert all single-error barcodes
		for ( my $i = 0; $i < length( $line[0] ); $i++ ) {
			my @chars = ( "A", "C", "G", "T", "N" );
			my $s = $line[0];
			foreach my $ck (@chars) {
				substr( $s, $_, 1 ) =~ s/[ACGT]/$ck/ for $i;
				print STDERR "Barcode collision! $s => $line[0] was already defined for read $line[2]!!\n" if defined $barcode{$rid}{$s} && $s ne $line[0];
				$barcode{$rid}{$s}{parent} = $line[0];
			}
		}
	}
	close($INBC);
	return %barcode;
}

# read barcodes to names mapping in QIIME mapping format
# column 1: sample name
# column 2: barcode, in XXXX:YYYY format if dual barcode
# columns 3+: arbitrary metadata
sub read_sample_file {
	my %args = @_;
	my $sample_file = $args{sample_file} || miss("sample_file");

	my %barcode_map;
	debug "Reading name mapping\n";
	my $INMAP = ps_open($sample_file);
	while ( my $line = <$INMAP> ) {
		chomp($line);
		next if $line =~ /^#/;
		my @line = split( /\t/, $line );
		next if @line < 2;
		if(defined($args{rev_barcode})){
			my @bc = split(/:/, $line[1]);
			if($args{rev_barcode}==3){
				$bc[0] = reverse($bc[0]);
			        $bc[0] =~ tr/ABCDGHMNRSTUVWXYabcdghmnrstuvwxy/TVGHCDKNYSAABWXRtvghcdknysaabwxr/;			
			}
			if($args{rev_barcode}==2){
				$bc[1] = reverse($bc[1]);
			        $bc[1] =~ tr/ABCDGHMNRSTUVWXYabcdghmnrstuvwxy/TVGHCDKNYSAABWXRtvghcdknysaabwxr/;			
			}
			$line[1] = $bc[0].":".$bc[1];
		}

		print STDERR "Mapping barcode $line[1] to $line[0]\n";
		$barcode_map{ $line[1] } = $line[0];
	}
	close($INMAP);
	return %barcode_map;
}

# clean up a fastq header line so it's compatible with MG-RAST
sub clean_line {
	my %args = @_;
	$args{line} =~ s/ /:/g;
	chomp $args{line};
	$args{line} .= "/".$args{num}."\n";
	return $args{line};
}

1;
